#include <stdio.h>

int main()
{
	int a[10];
	cout << &struct[0];
	cout << &struct[1];

}



/*
symbol table에 a, b 변수 선언한 변수들을
포인터형 변수, 심볼테이블을 모르면 이번 학기 F
연결 리스트 할 때 그림 먼저 그려야함.
화살표의 꼬리에 있는 변수는 머리에 있는 주소값을 나타낸다.
배열은 주소가 연속적으로 선언되고 따로따로 c1, c2 이런식으로 선언하면 메모리 주소가 중구남방으로 잡힌다.

****개발자가 자료구조에서 신경써야 할 것.
1. 메모리의 누수 관리
2. 동일한 일을 하는데 얼마나 빠른가?
-> 기능이 동일하다는 가정하에 일반적으로 속도>메모리 관리
-> 근데 컴퓨터에서만 돌리는게 아니기 때문에 속도<메모리

생각해봅시다.
1. 배열 크기보다 더 크게 잡으면 메모리 누수가 일어날 수 있다.
2. 나중에 추가 업데이트가 된다면 추가 챔피언이 늘어나 배열이 더 필요할 수 있다.
3. 그때 수정하면 된다.
4. 조금 여유롭게 만들면 편하지 않을까?
ㄴ 개발자의 편함은 고려상황이 아니다.
=> 배열의 크기를 늘리는 것은 가능하긴 하지만.. 없다고 가정하자.(동적할당 받아서 카피해서 포인터 받고 바꿀 수 있다.)
=> 배열의 크기를 바꿀 수 없으면 배열에 더 추가적으로 넣을 수 없다. 기능에서 차이가 있다.


결론
하고싶었던 얘기
-> 질문 열심히해라 안하면 모르고 넘어갈거다.
-> 데이터가 들어 있는 곳인지 아닌 곳인지 확인해봐야 한다. -> 다음시간에


*/