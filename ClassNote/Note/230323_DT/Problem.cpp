/*
3월 30일에 휴강을 할 수 없어서 비대면강의로 대체
그 다음주 시험에 유용할 것

3월 31일 문제
명령어 리스트 사용자가 내리는 명령
유닛 리스트 모든 생성된 유닛들의 현재 정보가 저장된 1차원 배열 // 죽은 유닛은 좌표 -1, -1로 표현 삭제는 유닛 리스트에서 뻄
내가 보는 것과 내부에서 보는 데이터 분리 1차원 배열에 유닛리스트 만들어서 보드판과 분리해라
초기데이타 + MakeUL() 리스트 만들어라 유닛리스트 만드는거 까지 넣기
1. MakeUL 하나씩 다 출력
3. 좌표 입력하면 그 좌표에 있는거를 유닛 리스트에서
5. 주어진 좌표의 유닛을 유닛리스트에서 찾아 삭제 죽은거랑 다름
뒤로갈수록 재귀함수가 더 편해질 수 있다. 구현해바라.
재귀함수들 5줄이나 다를까? printf, if정도
7. 그냥 맵그리기
필요하다면 재귀함수 짜서 2->1 덮어써도 된다.

1,2번은 똑같은 일을 한다.
1번은 for문을 써도 되고 2번을 그냥 불러도 된다.

ShowUL_R -> for문 대신 재귀함수 써라.
1,2,3,4,5,6번 switch로 선택해서 출력해라 하면 될듯

유닛 출력할 떄 


-prev
메모리를 얼마나 사용하느냐, 속도가 얼마나 빠르냐
주어진 환경에 따라 더 중요한게 다르다.
컴퓨터에선 메모리 가격이 줄어들어서 속도가 더 중요해 지고 있다.

생각해봅시다 - 배열
배열의 크기가 늘고 줄어듦을 고려하지 말자.
이 자료구조의 문제가 뭐인가? -> 만일 배열이면 크기가 고정되어 있다는게 문제다. -> 3학년 2학기에 배울 예정
배열의 크기와 데이터의 크기의 불균형이 생길 수 있다.

Q. 빈 배열에 쓰레기값이 들어있는지 중요한가? -> 유효하지 않은 값까지 출력하면 곤란하니 구분하자.
들어있는 값만으론 구분하기 힘드니 배열에 값을 넣을 때 값이 유효한지 구분하는 변수를 하나 더 추가하자.
-> 대체할 방법이 있으면 메모리와 속도에 부하를 주지 않고 구분할 수 있다.
-> HP나 name에 NULL 혹은 -1 이런식으로 초기화 해 검사한다.
-> 가독성이 떨어질 수 있다.
-> -200 같은 신규 챔피언이 기획되어서 -도 허용하면 큰일 날 수 있다.
-> 임의로 규칙을 만드는 것은 수정이 어려울 수 없다. 쓸 상황이 생기면 document, 주석을 잘 써놓고 잘 전달해야 한다.
 
Q. 둘다 없이 처리할 방법이 없나?
-> 앞줄에 꽉꽉 눌러 담아서 경계선을 긋고 경계선보다 앞에 있으면 유효 뒤에면 쓰레기값이라 보기.
-> 데이터 순서가 중요한 경우에 (미니스타 좌표 위치 등) 임의로 구분하면 그럴 수 없다. 
-> 앞으로 몰아넣는 것도 일이다.(메모리 소모)

최종 의견
1. alive 변수 새로 만들자.
2. 나중에 alive 변수 쓸 지 모르는데 0, 쓰레기값 넣고 하자.
3. 앞에서부터 순서대로 넣는다. 경계선을 따라 유효값, 쓰레기 값을 구분한다.


배열 알고리즘
1. 어디에서 부터 어떻게 찾는가?
배열의 처음부터 순서대로
2.찾으면 출력 후 멈추는가? or 계속 찾는가?
찾을 때까지?
마지막 데이터를 볼 떄까지?
배열의 끝가지?
3. 없는 경우 없다는 것을 어떻게 아는가?
모든 데이터를 봤으면?

HP가 500인 챔피언을 출력하는 프로그램
-> 미리 HP순으로 정렬해서 HP 500인 부분만 찾는다.
-> 정렬하면 그만큼 비용이 들어서 그 비용만큼 손해일 수 있다.
-> 그럼에도 보통 정렬하는 편이 좋으 ㄴ편이다.

생각해 봅시다 - 삽입
1. 추가할 자리를 어떻게 결정하는가? 앞? 뒤? 첫번쨰 빈자리?
2. 추가된 챔피언도 Search 할 수 있나?
3. 더 좋은 방법이 있나?
*/